# Implementación de un sistema de recomendación y un sistema de explicaciones
A continuación, se va a explicar cómo se han implementado los sistemas de recomendación y de explicaciones. La implementación de ambos sistemas se ha realizado en Python, y se ha creado una clase por cada uno de ellos: class Recomendador() y class Explicaciones(). También se ha creado la clase ``util'', con funciones como leer o guardar información, como pueden ser matrices o valoraciones, en un fichero .csv.

## Sistema recomendador
En la clase Recomendador se han incluido los métodos de entrenamiento, configuración y evaluación del modelo, así como los usados para obtener los juegos de mesa recomendados dado un usuario. 

Empezamos por los métodos de entrenamiento, ya que sin ellos no se puede configurar el modelo. Por un lado, se tiene la función que divide el dataset pasado por argumento, en nuestro caso será el dataset mencionado en la Sección \ref{SS:DATASET}, en los conjuntos trainset y testset, según el porcentaje de test pasado también por argumento. Para ello, se usa la función train_test_split del paquete sklearn. Además, en esta función se obtienen los diccionarios que relacionan a los usuarios y los juegos de mesa, del trainset, con su fila o columna en las matrices $P$ y $Q$, respectivamente. En estas matrices, los identificadores de los usuarios y de los juegos de mesa se ordenan de menor a mayor para asociarlos con la fila, en el caso de los usuario, o de la columna, en el caso de los juegos de mesa.

Una vez que se ha divido el dataset, se puede entrenar el modelo usando el trainset. Para ello, se crea una función, que recibe como argumento el número de factores latentes, y con ellos entrena el modelo usando el algoritmo NMF del paquete Surprise. Esto se hace usando la función fit, que recibe como argumento el trainset como la clase Trainset de Surprise. Es por ello que se necesita convertir el trainset a dicha clase usando la función built_full_trainset.

Ahora, una vez que podemos dividir el dataset en conjuntos de entrenamiento y test con distintos porcentajes, y entrenarlo usando distinto número de factores latentes, pasamos a las funciones que ayudan a configurar el modelo. Se ha implementado la función que, pasado un modelo entrenado con unos parámetros y un dataset con un conjunto de valoraciones de la forma (usuario, juego, valoración), calcula las predicciones de todas las entradas de ese dataset usando el modelo pasado. Esta función es usada por otra con los mismos argumentos que calcula el MAE de las predicciones devueltas por esta. Por último, se ha implementado una función que para el número de factores latentes entre 1 y 40, entrena el modelo con la función de entrenamiento que se ha hablado anteriormente, y calcula el MAE del trainset y del testset para cada número de factores latentes con los que se entrena el modelo. Devuelve dos listas, una con los MAE del testset, y otra con los del trainset. 

En cuanto a la evaluación, se han creado dos funciones, una que realiza una validación cruzada de 5 iteraciones que calcula el MAE, RMSE, y MSE, y la otra, que calcula esos mismas métricas de error con las predicciones hechas por nuestro modelo sobre el testset.

Ahora, vamos a hablar de dos funciones que no entrenan o evalúan o son un medio para configurar el modelo, sino que lo utilizan. Una de ellas, dado el identificador de un usuario y de un juego, devuelve la estimación de la valoración de ese usuario sobre ese juego de mesa. Para ello, usa la función predict del modelo, que ya se ha usado en otras funciones, que devuelve entre otros valores esa estimación. Para recomendar juegos a usuarios, se ha creado una función que recibe el identificador de un usuario y un número $k$, que indica la cantidad de juegos recomendados que se solicitan. 

## Sistema explicador
En cuanto a la clase class Explicaciones(), se han incluido las funciones que calculan las $Q_u$, las similitudes y las que generan las explicaciones.

Empezamos con la función que, dado el identificador de un usuario, devuelve su matriz Q_u correspondiente. Para ello, multiplicamos una fila fija $p_u \in M_{1\times F}(\R)$ de la matriz P (información sobre un usuario determinado en la fila $u$ de la matriz) por la matriz $Q$. Esta multiplicación no es la usual entre matrices, sino que consiste en multiplicar cada fila de la matriz de $Q$ por la fila fija, posición a posición. 

Luego, tenemos la función que calcula las similitudes entre el recomendado y los juegos jugados por el usuario similares a este. Para obtener estos juegos similares, primero, se van a calcular las similitudes entre el juego recomendado y los juegos que el usuario ya ha jugado usando la métrica del coseno. Esta función devuelve un diccionario de identificadores de los juegos de mesa  no jugados por el usuario pasado por argumento, con su similitud con el juego recomendado. A partir de estas similitudes, se crean dos funciones, una para obtener los $k$, valor que se pasa por argumento, juegos de mesa más similares al recomendado, y otra para obtener los juegos de mesa con una similitud con el juego recomendado por encima de cierto valor, que se pasa por argumento. Ambas funciones también reciben el identificador del juego recomendado y del usuario al que se le recomienda.

Por último, tenemos las funciones que generan las explicaciones. Se han implementado tres, una que genera las explicaciones acerca de la edad y el número de jugadores recomendados; una segunda que genera las explicaciones sobre la dificultad, y una última que genera las explicaciones de los tipos, categorías y mecánicas. Como la información que devuelven estas funciones sirve para mostrársela a los usuarios, se ha incluido un argumento extra para indicar cuántos juegos se quieren mostrar a los usuarios. 

## Tutorial
En el fichero Tutorial.ipynb se encuentra un ejemplo de cómo usar las librerías explicadas. En el ejemplo, primero se entrena el modelo, y una vez entrenado, se le hace una recomendación de un juego a un usuario en concreto. A partir de esta recomendación, se obtienen sus juegos similares y se extraen las cuatro explicaciones: edad recomendada, número de jugadores, dificultad, y tipos, categorías y mecánicas. Una vez se tienen las explicaciones, se presentan al usuario. 